---
phase: 01-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/config.toml
  - supabase/migrations/20260217000001_expenses_qbo_columns.sql
  - supabase/migrations/20260217000002_qbo_connection.sql
  - .gitignore
autonomous: true

must_haves:
  truths:
    - "Supabase CLI is initialized and linked to the existing hosted project"
    - "expenses table has qbo_purchase_id, qbo_pushed_at, qbo_error, qbo_sync_attempts columns"
    - "qbo_connection table exists with realm_id, token_vault_id, refresh_token_vault_id, token_expires_at"
    - "Vault extension is enabled and wrapper functions (create_vault_secret, read_vault_secret, update_vault_secret) exist in public schema"
    - "RLS on qbo_connection denies all non-service_role access"
  artifacts:
    - path: "supabase/config.toml"
      provides: "Supabase project configuration"
    - path: "supabase/migrations/20260217000001_expenses_qbo_columns.sql"
      provides: "QBO sync columns on expenses table"
      contains: "ADD COLUMN IF NOT EXISTS qbo_purchase_id"
    - path: "supabase/migrations/20260217000002_qbo_connection.sql"
      provides: "QBO connection table, Vault extension, wrapper functions, RLS"
      contains: "CREATE TABLE IF NOT EXISTS qbo_connection"
  key_links:
    - from: "supabase/migrations/20260217000002_qbo_connection.sql"
      to: "vault.create_secret"
      via: "SECURITY DEFINER wrapper function"
      pattern: "create_vault_secret"
    - from: "supabase/migrations/20260217000002_qbo_connection.sql"
      to: "vault.decrypted_secrets"
      via: "SECURITY DEFINER wrapper function"
      pattern: "read_vault_secret"
---

<objective>
Initialize Supabase CLI project structure and create database migrations for QBO integration columns.

Purpose: Every subsequent plan in Phase 1 (and beyond) depends on the supabase/ directory existing and the database schema being ready. This plan establishes the foundation: CLI initialization, project linking, and two SQL migrations that add QBO sync columns to the existing expenses table and create the qbo_connection table with Vault-encrypted token storage references.

Output: supabase/ directory with config.toml, two migration files applied to the database, Vault extension enabled, and public schema wrapper functions for Vault access.
</objective>

<execution_context>
@C:\Users\Gustavo\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Gustavo\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
@src/services/supabase.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize Supabase CLI and link to existing project</name>
  <files>supabase/config.toml, .gitignore</files>
  <action>
1. Run `npx supabase init` in the project root to create the `supabase/` directory with `config.toml`. Use `npx` to avoid requiring a global install.

2. Run `npx supabase login` to authenticate the CLI. If auth fails, the executor should note it and continue — the user will authenticate manually.

3. Run `npx supabase link --project-ref <PROJECT_REF>` to link to the existing Supabase project. The project ref can be found from the existing `VITE_SUPABASE_URL` environment variable — it's the subdomain portion (e.g., `https://abcdefg.supabase.co` means project ref is `abcdefg`). Check `.env` or `.env.local` for `VITE_SUPABASE_URL` to extract the ref.

4. Run `npx supabase functions new qbo-api` to create the Edge Function scaffold directory (`supabase/functions/qbo-api/index.ts`). This is needed by Plan 02 — creating it here avoids Plan 02 needing to run supabase CLI commands.

5. Add `supabase/.env.local` and `supabase/.temp/` to `.gitignore` if not already present. These contain local secrets and temporary files that must never be committed.

IMPORTANT: If `supabase login` requires interactive browser auth that fails in CLI, note it in output. The user can run `npx supabase login` manually. This should NOT block the rest of the plan — continue with init and file creation. The `supabase link` and `supabase db push` steps can be retried after login.
  </action>
  <verify>
- `supabase/config.toml` exists
- `supabase/functions/qbo-api/index.ts` exists (scaffold)
- Run `npx supabase status` shows linked project (or note if login needed)
- `.gitignore` includes `supabase/.env.local`
  </verify>
  <done>supabase/ directory exists with config.toml, functions/qbo-api/ scaffold created, .gitignore updated</done>
</task>

<task type="auto">
  <name>Task 2: Create and apply database migrations</name>
  <files>supabase/migrations/20260217000001_expenses_qbo_columns.sql, supabase/migrations/20260217000002_qbo_connection.sql</files>
  <action>
Create two migration files in `supabase/migrations/`:

**Migration 1: `20260217000001_expenses_qbo_columns.sql`**
Safe addition of QBO sync columns to the existing production `expenses` table. Uses `ADD COLUMN IF NOT EXISTS` so it is idempotent and safe for tables with existing data.

```sql
-- QBO sync columns for expenses table
-- Safe: uses IF NOT EXISTS, all new columns are nullable except qbo_sync_attempts (defaults to 0)

ALTER TABLE expenses
  ADD COLUMN IF NOT EXISTS qbo_purchase_id TEXT,
  ADD COLUMN IF NOT EXISTS qbo_pushed_at TIMESTAMPTZ,
  ADD COLUMN IF NOT EXISTS qbo_error TEXT,
  ADD COLUMN IF NOT EXISTS qbo_sync_attempts INTEGER NOT NULL DEFAULT 0;

-- Index for efficient "unsynced expenses" queries (partial index on unpushed rows)
CREATE INDEX IF NOT EXISTS idx_expenses_qbo_sync
  ON expenses (qbo_pushed_at, qbo_sync_attempts)
  WHERE qbo_pushed_at IS NULL;
```

**Migration 2: `20260217000002_qbo_connection.sql`**
Creates the qbo_connection table, enables Vault, creates Vault wrapper functions, and sets up RLS.

```sql
-- Enable Vault extension (safe if already enabled)
CREATE EXTENSION IF NOT EXISTS vault WITH SCHEMA vault;

-- QBO connection metadata table
-- Stores realm_id and Vault secret UUIDs (NOT the tokens themselves)
CREATE TABLE IF NOT EXISTS qbo_connection (
  id                       UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  realm_id                 TEXT NOT NULL UNIQUE,
  company_name             TEXT,
  token_vault_id           UUID NOT NULL,
  refresh_token_vault_id   UUID NOT NULL,
  token_expires_at         TIMESTAMPTZ NOT NULL,
  token_issued_at          TIMESTAMPTZ NOT NULL DEFAULT now(),
  connected_at             TIMESTAMPTZ NOT NULL DEFAULT now(),
  is_active                BOOLEAN NOT NULL DEFAULT true
);

-- RLS: deny all access to non-service_role callers
ALTER TABLE qbo_connection ENABLE ROW LEVEL SECURITY;
CREATE POLICY "deny_all_users" ON qbo_connection
  FOR ALL USING (false);

-- Vault wrapper functions (SECURITY DEFINER, service_role only)
-- These allow Edge Functions to call vault operations via .rpc()

CREATE OR REPLACE FUNCTION create_vault_secret(secret TEXT, name TEXT DEFAULT NULL)
RETURNS UUID
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  result UUID;
BEGIN
  SELECT id INTO result FROM vault.create_secret(secret, name);
  RETURN result;
END;
$$;
REVOKE ALL ON FUNCTION create_vault_secret(TEXT, TEXT) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION create_vault_secret(TEXT, TEXT) TO service_role;

CREATE OR REPLACE FUNCTION read_vault_secret(secret_id UUID)
RETURNS TEXT
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  result TEXT;
BEGIN
  SELECT decrypted_secret INTO result
  FROM vault.decrypted_secrets
  WHERE id = secret_id;
  RETURN result;
END;
$$;
REVOKE ALL ON FUNCTION read_vault_secret(UUID) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION read_vault_secret(UUID) TO service_role;

CREATE OR REPLACE FUNCTION update_vault_secret(secret_id UUID, new_secret TEXT)
RETURNS VOID
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  PERFORM vault.update_secret(secret_id, new_secret);
END;
$$;
REVOKE ALL ON FUNCTION update_vault_secret(UUID, TEXT) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION update_vault_secret(UUID, TEXT) TO service_role;
```

After creating the files, attempt to push migrations to the database:
- Run `npx supabase db push` to apply migrations to the linked project.
- If this fails because CLI is not logged in yet, note it — migrations can be applied later.
- Do NOT use `supabase db reset` — that would destroy production data.
  </action>
  <verify>
- Both migration files exist at the correct paths
- SQL syntax is valid (no obvious errors)
- If `supabase db push` succeeded: query the database to confirm columns exist — `npx supabase db execute "SELECT column_name FROM information_schema.columns WHERE table_name = 'expenses' AND column_name LIKE 'qbo_%'"` should return 4 rows
- If push was deferred: migration files are ready to apply when CLI auth is resolved
  </verify>
  <done>Two migration files created. If CLI is authenticated: expenses table has 4 new QBO columns, qbo_connection table exists with RLS, Vault enabled, 3 wrapper functions created. If CLI auth deferred: files ready to apply.</done>
</task>

</tasks>

<verification>
1. `supabase/config.toml` exists in project root
2. `supabase/functions/qbo-api/index.ts` scaffold exists
3. `supabase/migrations/` contains two .sql files
4. Migration SQL uses `IF NOT EXISTS` / `ADD COLUMN IF NOT EXISTS` (safe for production data)
5. `qbo_connection` table has RLS enabled with deny-all policy
6. Three Vault wrapper functions (create, read, update) are SECURITY DEFINER and service_role only
7. `.gitignore` includes supabase local secrets
</verification>

<success_criteria>
- supabase/ directory initialized and linked to existing project
- expenses table extended with qbo_purchase_id, qbo_pushed_at, qbo_error, qbo_sync_attempts
- qbo_connection table created with all required columns
- Vault extension enabled, 3 wrapper functions in public schema
- No existing data in expenses table was modified or deleted
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-01-SUMMARY.md`
</output>
