---
phase: 01-foundation
plan: 03
type: execute
wave: 3
depends_on: ["01-01", "01-02"]
files_modified:
  - supabase/functions/qbo-api/index.ts
  - src/components/QboConnectionStatus.tsx
  - src/services/qboService.ts
  - src/App.tsx
autonomous: false

user_setup:
  - service: quickbooks-online
    why: "OAuth 2.0 connection to QBO sandbox"
    env_vars:
      - name: QBO_CLIENT_ID
        source: "Intuit Developer Dashboard -> App 0d714481... -> Keys & credentials -> Client ID"
      - name: QBO_CLIENT_SECRET
        source: "Intuit Developer Dashboard -> App 0d714481... -> Keys & credentials -> Client Secret"
      - name: QBO_REDIRECT_URI
        source: "Set to https://[PROJECT_REF].supabase.co/functions/v1/qbo-api/auth/callback"
      - name: QBO_FRONTEND_URL
        source: "Your frontend URL (e.g., http://localhost:5173 for dev)"
    dashboard_config:
      - task: "Register the OAuth redirect URI in QBO Developer Dashboard"
        location: "Intuit Developer Dashboard -> App 0d714481... -> Keys & credentials -> Redirect URIs -> Add https://[PROJECT_REF].supabase.co/functions/v1/qbo-api/auth/callback"

must_haves:
  truths:
    - "Admin can click 'Connect to QuickBooks' and is redirected to QBO OAuth consent screen"
    - "After granting consent, QBO redirects back and tokens are stored encrypted in Supabase Vault"
    - "After successful connection, the UI shows 'Connected to QuickBooks' badge with company name"
    - "The Connect button is only visible to admin (simple gate, not full auth system)"
    - "Connection status persists across page refresh"
    - "OAuth state parameter prevents CSRF attacks"
  artifacts:
    - path: "supabase/functions/qbo-api/index.ts"
      provides: "OAuth route handlers (/auth/start, /auth/callback, /connection/status)"
      contains: "auth/start"
    - path: "src/components/QboConnectionStatus.tsx"
      provides: "Connect to QuickBooks button and connected status badge"
      min_lines: 40
    - path: "src/services/qboService.ts"
      provides: "Frontend functions to invoke Edge Function endpoints"
      min_lines: 20
    - path: "src/App.tsx"
      provides: "QboConnectionStatus component integrated into header"
      contains: "QboConnectionStatus"
  key_links:
    - from: "src/components/QboConnectionStatus.tsx"
      to: "src/services/qboService.ts"
      via: "import and function calls"
      pattern: "getConnectionStatus|startOAuthFlow"
    - from: "src/services/qboService.ts"
      to: "supabase/functions/qbo-api/index.ts"
      via: "supabase.functions.invoke('qbo-api')"
      pattern: "functions\\.invoke"
    - from: "supabase/functions/qbo-api/index.ts"
      to: "vault.create_secret"
      via: "RPC call to store tokens"
      pattern: "create_vault_secret"
    - from: "supabase/functions/qbo-api/index.ts"
      to: "qbo_connection"
      via: "upsert after OAuth callback"
      pattern: "qbo_connection.*upsert"
---

<objective>
Implement the QBO OAuth 2.0 flow: /auth/start endpoint, /auth/callback endpoint with Vault token storage, /connection/status endpoint, and a frontend "Connect to QuickBooks" button with connection status badge.

Purpose: This is the single most important plan in Phase 1 — it establishes the QBO connection that every future phase depends on. After this plan, BMB's admin can connect the company's QBO account, and tokens are securely stored for all future API calls.

Output: Three new route handlers in the Edge Function, a frontend QboConnectionStatus component showing either a "Connect" button or a green "Connected" badge, and a qboService module for Edge Function communication.
</objective>

<execution_context>
@C:\Users\Gustavo\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Gustavo\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
@.planning/phases/01-foundation/01-02-SUMMARY.md
@src/services/supabase.ts
@src/App.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement OAuth route handlers in Edge Function</name>
  <files>supabase/functions/qbo-api/index.ts</files>
  <action>
Add three route handlers to the existing Hono app in `supabase/functions/qbo-api/index.ts`. Replace the placeholder comments from Plan 02 with real implementations.

**Route 1: GET /auth/start**
Purpose: Generate QBO OAuth authorization URL and return it to the frontend.

Implementation:
1. Generate a CSRF state token using `crypto.randomUUID()`.
2. Store the state temporarily — use the `qbo_connection` table with a temporary row, OR store in a simple in-memory Map keyed by state (acceptable since this is a single-company admin-only flow, not a multi-user system). Choose the simpler in-memory approach: `const pendingStates = new Map<string, number>()` at module level, storing `state -> Date.now()`. Clean up entries older than 10 minutes.
3. Build the authorization URL:
   - Base: `https://appcenter.intuit.com/connect/oauth2`
   - Params: `client_id`, `redirect_uri`, `response_type=code`, `scope=com.intuit.quickbooks.accounting`, `state`
   - Get `client_id` from `Deno.env.get('QBO_CLIENT_ID')`
   - Get `redirect_uri` from `Deno.env.get('QBO_REDIRECT_URI')`
4. Return JSON: `{ url: authUrl.toString() }`

**Route 2: GET /auth/callback**
Purpose: Handle QBO OAuth redirect, exchange code for tokens, store in Vault, redirect browser back to frontend.

CRITICAL: This route is EXCLUDED from JWT middleware (already set up in Plan 02). The browser navigates here directly from QBO — there is no Authorization header.

Implementation:
1. Extract query params: `code`, `state`, `realmId` from the request URL.
2. Validate `state` against `pendingStates` Map. If invalid or expired, redirect to frontend with `?qbo_error=invalid_state`. Delete the state entry after validation (one-time use).
3. Exchange authorization code for tokens:
   ```
   POST https://oauth.platform.intuit.com/oauth2/v1/tokens/bearer
   Authorization: Basic btoa(clientId:clientSecret)
   Content-Type: application/x-www-form-urlencoded
   Body: grant_type=authorization_code&code=CODE&redirect_uri=REDIRECT_URI
   ```
4. Parse response: extract `access_token`, `refresh_token`, `expires_in` (3600 seconds).
5. Store tokens in Vault using the service_role client:
   - `const { data: accessVaultId } = await serviceClient.rpc('create_vault_secret', { secret: tokens.access_token, name: 'qbo_access_token' })`
   - `const { data: refreshVaultId } = await serviceClient.rpc('create_vault_secret', { secret: tokens.refresh_token, name: 'qbo_refresh_token' })`
6. Fetch company name from QBO using the new access token:
   ```
   GET https://sandbox-quickbooks.api.intuit.com/v3/company/{realmId}/companyinfo/{realmId}?minorversion=75
   Authorization: Bearer access_token
   ```
   Extract `CompanyName` from response. If this fails, use `null` for company_name — do not block the flow.
7. Upsert into `qbo_connection` table (using service_role client):
   ```typescript
   await serviceClient.from('qbo_connection').upsert({
     realm_id: realmId,
     company_name: companyName,
     token_vault_id: accessVaultId,
     refresh_token_vault_id: refreshVaultId,
     token_expires_at: new Date(Date.now() + tokens.expires_in * 1000).toISOString(),
     token_issued_at: new Date().toISOString(),
     is_active: true,
   }, { onConflict: 'realm_id' })
   ```
8. Log success to console: `console.log('[OAuth] Connected:', realmId, companyName)`
9. Return 302 redirect to frontend:
   ```typescript
   return c.redirect(`${Deno.env.get('QBO_FRONTEND_URL')}?qbo_connected=true`)
   ```
10. On any error, log the error and redirect with error:
    ```typescript
    return c.redirect(`${Deno.env.get('QBO_FRONTEND_URL')}?qbo_error=token_exchange_failed`)
    ```

**Route 3: GET /connection/status**
Purpose: Return whether QBO is connected and the company name. Safe for frontend consumption — never returns tokens.

Implementation:
1. Query `qbo_connection` table for active connection:
   ```typescript
   const { data } = await serviceClient
     .from('qbo_connection')
     .select('company_name, is_active, connected_at')
     .eq('is_active', true)
     .single()
   ```
2. Return JSON:
   ```json
   { "connected": true/false, "company_name": "BMB Enterprises Inc." or null }
   ```

IMPORTANT: The `/connection/status` route IS behind JWT middleware. The frontend must send a Supabase auth token. However, since the app has no auth yet, this creates a chicken-and-egg problem. For Phase 1, add a temporary bypass: if no Supabase Auth is configured (no JWT), still allow `/connection/status` to return data. Add a TODO comment noting this should be locked down when auth is added.

Actually, simpler approach: Add `/connection/status` to the JWT middleware exclusion list alongside `/auth/callback`. The connection status is not sensitive (just a boolean + company name). Mark with a TODO to lock down later when the app has auth.
  </action>
  <verify>
- `index.ts` contains `app.get('/auth/start', ...)` handler
- `index.ts` contains `app.get('/auth/callback', ...)` handler
- `index.ts` contains `app.get('/connection/status', ...)` handler
- `/auth/callback` is excluded from JWT middleware
- `/connection/status` is excluded from JWT middleware (temporary for Phase 1)
- Token exchange uses correct QBO endpoint and Basic auth encoding
- Tokens are stored via `create_vault_secret` RPC calls
- qbo_connection upsert includes all required columns
- Callback redirects to frontend URL (not JSON response)
- No token values are returned in any response — only Vault UUIDs are stored in the DB
  </verify>
  <done>Three OAuth route handlers implemented: /auth/start returns authorization URL, /auth/callback exchanges code for tokens and stores in Vault, /connection/status returns connection boolean and company name. All token storage goes through Vault wrapper functions.</done>
</task>

<task type="auto">
  <name>Task 2: Build frontend QBO connection UI</name>
  <files>src/services/qboService.ts, src/components/QboConnectionStatus.tsx, src/App.tsx</files>
  <action>
Create two new files and modify App.tsx to add the "Connect to QuickBooks" button and connection status badge.

**File 1: `src/services/qboService.ts`**
Frontend service module for communicating with the QBO Edge Function.

```typescript
import { createClient } from '@supabase/supabase-js'

// Re-use the same Supabase client config from supabase.ts
const supabaseUrl = (import.meta.env.VITE_SUPABASE_URL || '').trim()
const supabaseAnonKey = (import.meta.env.VITE_SUPABASE_ANON_KEY || '').trim()

interface ConnectionStatus {
  connected: boolean
  company_name: string | null
}

/**
 * Check if QBO is connected. Calls the Edge Function /connection/status endpoint.
 */
export async function getConnectionStatus(): Promise<ConnectionStatus> {
  const response = await fetch(
    `${supabaseUrl}/functions/v1/qbo-api/connection/status`,
    {
      headers: {
        'Authorization': `Bearer ${supabaseAnonKey}`,
      },
    }
  )
  if (!response.ok) {
    console.error('[QBO] Failed to check connection status:', response.status)
    return { connected: false, company_name: null }
  }
  return response.json()
}

/**
 * Start OAuth flow. Gets the authorization URL from the Edge Function,
 * then redirects the browser to QBO's consent page.
 */
export async function startOAuthFlow(): Promise<void> {
  const response = await fetch(
    `${supabaseUrl}/functions/v1/qbo-api/auth/start`,
    {
      headers: {
        'Authorization': `Bearer ${supabaseAnonKey}`,
      },
    }
  )
  if (!response.ok) {
    throw new Error('Failed to start OAuth flow')
  }
  const { url } = await response.json()
  // Redirect the entire browser to QBO consent page
  window.location.href = url
}
```

NOTE: Using `fetch` directly instead of `supabase.functions.invoke()` because the auth/start endpoint needs to return a URL for browser redirect, and functions.invoke has additional response wrapping. Direct fetch is simpler and more predictable here.

**File 2: `src/components/QboConnectionStatus.tsx`**
React component that shows either:
- "Connect to QuickBooks" button (when disconnected)
- Green "Connected to QuickBooks: [Company Name]" badge (when connected)

Implementation:
1. Use `useState` for `connected` (boolean), `companyName` (string|null), `loading` (boolean), `error` (string|null).
2. Use `useEffect` on mount to call `getConnectionStatus()`.
3. Also check URL params on mount: if `?qbo_connected=true` is present, show a brief success message and re-check status. If `?qbo_error=...` is present, show error. Clean up URL params after reading them using `window.history.replaceState`.
4. Admin gate: Use a simple approach — accept an `isAdmin` prop (boolean). When false, render nothing. The parent component controls who sees this. For Phase 1, hardcode `isAdmin={true}` in App.tsx since there's no auth system yet. Add a TODO comment: "Replace with real admin check when Supabase Auth is added."
5. Styling: Use inline styles consistent with the existing app style (the app uses inline styles, not CSS classes or Tailwind):
   - Button: green (#2e7d32) background, white text, rounded, with Intuit-style appearance
   - Badge: green (#dcfce7) background, green (#166534) text, rounded pill shape
   - Loading: subtle "Checking..." text
   - Error: red text with retry option

**File 3: `src/App.tsx` (modify)**
Add the QboConnectionStatus component to the header, positioned to the right of the "Receipt Scanner" title.

1. Import `QboConnectionStatus` from `./components/QboConnectionStatus`
2. Add it inside the `<header>` element, after the `<h1>` tag
3. Adjust header layout to `display: flex`, `justify-content: space-between`, `align-items: center` so the title is on the left and the QBO status is on the right
4. Pass `isAdmin={true}` for now (hardcoded, with TODO comment)

Keep the header compact — the QBO status should be small and unobtrusive, not dominating the mobile layout.
  </action>
  <verify>
- `src/services/qboService.ts` exists with `getConnectionStatus()` and `startOAuthFlow()` functions
- `src/components/QboConnectionStatus.tsx` exists and renders a button or badge based on connection state
- `src/App.tsx` imports and renders `QboConnectionStatus` in the header
- `npm run build` succeeds (TypeScript compiles without errors)
- URL parameter handling: `?qbo_connected=true` triggers status re-check, `?qbo_error=...` shows error message
- No Supabase auth tokens or QBO tokens are exposed in the frontend code
  </verify>
  <done>Frontend has QboConnectionStatus component in the header showing "Connect to QuickBooks" button or "Connected" badge. qboService module handles Edge Function communication. App.tsx integrates the component with hardcoded isAdmin=true (TODO for real auth later).</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify OAuth flow end-to-end</name>
  <what-built>Complete QBO OAuth flow: Edge Function with /auth/start, /auth/callback, /connection/status endpoints; frontend "Connect to QuickBooks" button; Vault token storage; connection status badge</what-built>
  <how-to-verify>
Prerequisites: Ensure these Edge Function secrets are set (if not already done during execution):
- `npx supabase secrets set QBO_CLIENT_ID=your_client_id QBO_CLIENT_SECRET=your_client_secret QBO_REDIRECT_URI=https://[ref].supabase.co/functions/v1/qbo-api/auth/callback QBO_FRONTEND_URL=http://localhost:5173`
- Ensure the QBO Developer Dashboard has the redirect URI registered

Test steps:
1. Start the dev server: `npm run dev`
2. Open http://localhost:5173 in the browser
3. Verify the header shows "Connect to QuickBooks" button on the right side
4. Click the button — you should be redirected to Intuit's OAuth consent page
5. Log in with your QBO sandbox credentials and grant access
6. After consent, you should be redirected back to http://localhost:5173?qbo_connected=true
7. The button should be replaced with a green "Connected to QuickBooks: [Company Name]" badge
8. Refresh the page — the green badge should persist (connection status loaded from database)
9. Check Supabase Dashboard -> Table Editor -> qbo_connection: should have a row with realm_id and vault UUIDs
10. Check Supabase Dashboard -> Vault: should have two secrets (access_token, refresh_token)

If any step fails, describe what happened.
  </how-to-verify>
  <resume-signal>Type "approved" or describe what failed</resume-signal>
</task>

</tasks>

<verification>
1. Edge Function has three route handlers: /auth/start, /auth/callback, /connection/status
2. OAuth state parameter prevents CSRF (generated in /auth/start, validated in /auth/callback)
3. Token exchange uses correct QBO endpoint with Basic auth encoding
4. Access and refresh tokens stored in Vault via wrapper functions, UUIDs stored in qbo_connection table
5. /auth/callback redirects browser back to frontend (302), not JSON response
6. Frontend QboConnectionStatus component shows button (disconnected) or badge (connected)
7. URL parameters (?qbo_connected=true) handled and cleaned up
8. Connection status persists across page refresh
9. No tokens exposed in frontend code or API responses
10. `npm run build` succeeds
</verification>

<success_criteria>
- Admin can complete the full OAuth flow: click button -> QBO consent -> redirect back -> see green "Connected" badge
- Tokens are encrypted in Supabase Vault (not plain text in any table)
- Connection status shows company name and persists across refresh
- The existing receipt scanning functionality is unaffected
- Frontend builds without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md`
</output>
